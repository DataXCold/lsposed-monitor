# .github/workflows/monitor_lsposed.yml

name: Monitor LSPosed Artifacts

on:
  schedule:
    # Runs every 15 minutes to check for new artifacts
    - cron: "*/15 * * * *"
  workflow_dispatch: # Allows manual execution from Actions tab
    inputs:
      force_notification:
        description: 'Force send notification even if no new commit'
        required: false
        default: false
        type: boolean

env:
  TARGET_REPO: "JingMatrix/LSPosed"
  CACHE_VERSION: "v1" # Increment to invalidate cache if needed

jobs:
  check-for-artifacts:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore tracking data from cache
        id: cache-restore
        uses: actions/cache/restore@v4
        with:
          path: |
            .github/tracking/last_run_id.txt
            .github/tracking/last_commit_id.txt
          key: ${{ runner.os }}-lsposed-monitor-${{ env.CACHE_VERSION }}
          restore-keys: |
            ${{ runner.os }}-lsposed-monitor-

      - name: Create tracking directory
        run: mkdir -p .github/tracking

      - name: Fetch latest workflow run
        id: fetch_run
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          echo "ðŸ” Fetching latest successful workflow run from ${TARGET_REPO}..."
          
          # Retry logic for API calls
          for attempt in {1..3}; do
            echo "Attempt $attempt/3"
            
            if response=$(gh api \
              "repos/${TARGET_REPO}/actions/runs" \
              --jq '.workflow_runs[] | select(.conclusion == "success") | {id, head_sha, html_url, created_at, workflow_id} | select(.workflow_id != null)' \
              --paginate \
              --limit 1 2>/dev/null); then
              break
            fi
            
            if [ $attempt -eq 3 ]; then
              echo "âŒ Failed to fetch workflow runs after 3 attempts"
              exit 1
            fi
            
            echo "â³ Retrying in 5 seconds..."
            sleep 5
          done
          
          if [ -z "$response" ]; then
            echo "âŒ No successful workflow runs found"
            echo "status=no_runs" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Parse response
          run_id=$(echo "$response" | jq -r '.id // empty')
          commit_sha=$(echo "$response" | jq -r '.head_sha // empty')
          run_url=$(echo "$response" | jq -r '.html_url // empty')
          created_at=$(echo "$response" | jq -r '.created_at // empty')
          
          if [ -z "$run_id" ] || [ -z "$commit_sha" ]; then
            echo "âŒ Invalid response from API"
            echo "status=api_error" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "âœ… Found run ID: $run_id"
          echo "âœ… Commit SHA: $commit_sha"
          echo "âœ… Created: $created_at"
          
          # Store in outputs
          {
            echo "status=success"
            echo "run_id=$run_id"
            echo "commit_sha=$commit_sha"
            echo "run_url=$run_url"
            echo "commit_short=$(echo $commit_sha | cut -c1-7)"
            echo "created_at=$created_at"
          } >> $GITHUB_OUTPUT

      - name: Check if notification needed
        id: check_notification
        if: steps.fetch_run.outputs.status == 'success'
        run: |
          set -euo pipefail
          
          current_run_id="${{ steps.fetch_run.outputs.run_id }}"
          current_commit="${{ steps.fetch_run.outputs.commit_sha }}"
          force_notify="${{ github.event.inputs.force_notification || 'false' }}"
          
          # Read previous tracking data
          prev_run_id=$(cat .github/tracking/last_run_id.txt 2>/dev/null || echo "")
          prev_commit=$(cat .github/tracking/last_commit_id.txt 2>/dev/null || echo "")
          
          echo "ðŸ“Š Comparison:"
          echo "  Current run ID: $current_run_id"
          echo "  Previous run ID: $prev_run_id"
          echo "  Current commit: $current_commit"
          echo "  Previous commit: $prev_commit"
          echo "  Force notification: $force_notify"
          
          should_notify="false"
          reason=""
          
          if [ "$force_notify" = "true" ]; then
            should_notify="true"
            reason="Manual trigger (force notification enabled)"
          elif [ -z "$prev_commit" ]; then
            should_notify="true"
            reason="First run - no previous data found"
          elif [ "$current_commit" != "$prev_commit" ]; then
            should_notify="true"
            reason="New commit detected"
          else
            reason="Same commit as previous notification"
          fi
          
          echo "ðŸ”” Notification decision: $should_notify"
          echo "ðŸ“ Reason: $reason"
          
          {
            echo "should_notify=$should_notify"
            echo "reason=$reason"
          } >> $GITHUB_OUTPUT

      - name: Update tracking data
        if: steps.check_notification.outputs.should_notify == 'true'
        run: |
          echo "${{ steps.fetch_run.outputs.run_id }}" > .github/tracking/last_run_id.txt
          echo "${{ steps.fetch_run.outputs.commit_sha }}" > .github/tracking/last_commit_id.txt
          echo "âœ… Updated tracking data"

      - name: Save tracking data to cache
        if: steps.check_notification.outputs.should_notify == 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            .github/tracking/last_run_id.txt
            .github/tracking/last_commit_id.txt
          key: ${{ runner.os }}-lsposed-monitor-${{ env.CACHE_VERSION }}-${{ github.run_id }}

      - name: Send Telegram notification
        if: steps.check_notification.outputs.should_notify == 'true'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          format: markdown
          message: |
            ðŸ”” *New LSPosed Artifact Available!*
            
            ðŸ“¦ **Repository**: `${{ env.TARGET_REPO }}`
            ðŸ†” **Commit**: `${{ steps.fetch_run.outputs.commit_short }}`
            ðŸ“… **Build Date**: ${{ steps.fetch_run.outputs.created_at }}
            ðŸ“‹ **Reason**: ${{ steps.check_notification.outputs.reason }}
            
            ðŸ”— **Download artifacts**:
            ${{ steps.fetch_run.outputs.run_url }}
            
            _Automated by GitHub Actions_ âš¡ï¸

      - name: Log workflow summary
        if: always()
        run: |
          echo "## ðŸ“Š LSPosed Monitor Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.fetch_run.outputs.status }}" = "success" ]; then
            echo "âœ… **Status**: Successfully checked for new artifacts" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ” **Latest Run**: ${{ steps.fetch_run.outputs.run_id }}" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“ **Commit**: \`${{ steps.fetch_run.outputs.commit_short }}\`" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ steps.check_notification.outputs.should_notify }}" = "true" ]; then
              echo "ðŸ”” **Notification**: Sent" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ“‹ **Reason**: ${{ steps.check_notification.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "ðŸ”• **Notification**: Skipped" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ“‹ **Reason**: ${{ steps.check_notification.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âŒ **Status**: ${{ steps.fetch_run.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "_Last checked: $(date -u '+%Y-%m-%d %H:%M:%S UTC')_" >> $GITHUB_STEP_SUMMARY

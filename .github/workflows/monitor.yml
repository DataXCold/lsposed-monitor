# .github/workflows/monitor_lsposed.yml

name: Monitor LSPosed Artifacts

permissions:
  actions: read
  contents: read

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

on:
  schedule:
    # Runs every 15 minutes to check for new artifacts
    - cron: "*/15 * * * *"
  workflow_dispatch:
    inputs:
      force_notification:
        description: 'Force send notification even if no new commit'
        required: false
        default: false
        type: boolean

env:
  # Configuration for the repository and workflow to monitor
  TARGET_REPO: "JingMatrix/LSPosed"
  # Name of the specific workflow file that produces the release artifacts.
  # This makes the check more precise.
  WORKFLOW_FILE_NAME: "ci.yml" 
  
  # A version for the cache key, allows for manual cache invalidation
  CACHE_VERSION: "v4"
  # The file used to track the last notified commit SHA
  TRACKING_FILE: "last_notified_commit.txt"

jobs:
  check-for-artifacts:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      should_notify: ${{ steps.check_notification.outputs.should_notify }}
      notification_payload: ${{ steps.prepare_message.outputs.payload }}
      
    steps:
      - name: üìÇ Restore last notified commit from cache
        id: cache-restore
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.TRACKING_FILE }}
          # Use a single, consistent key for restoring and saving
          key: lsposed-monitor-cache-${{ env.CACHE_VERSION }}

      - name: üìù Read previous commit from file
        id: read_prev_commit
        run: |
          if [[ -f "${{ env.TRACKING_FILE }}" ]]; then
            prev_commit=$(cat "${{ env.TRACKING_FILE }}" | tr -d '[:space:]')
            echo "prev_commit=$prev_commit" >> "$GITHUB_OUTPUT"
            echo "üìÅ Found previous commit: $prev_commit"
          else
            echo "prev_commit=" >> "$GITHUB_OUTPUT"
            echo "ü§∑ No previous commit file found. Will notify on first successful find."
          fi

      - name: üîç Fetch latest successful workflow run
        id: fetch_run
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          echo "üîç Fetching latest successful run of '${{ env.WORKFLOW_FILE_NAME }}' from '${{ env.TARGET_REPO }}'..."
          
          response=""
          for attempt in {1..3}; do
            echo "Attempt $attempt/3..."
            # Query the API for the most recent successful run of a specific workflow file.
            # This is more reliable than just taking the latest run of any workflow.
            api_output=$(gh api "repos/${{ env.TARGET_REPO }}/actions/workflows/${{ env.WORKFLOW_FILE_NAME }}/runs" \
              --method GET \
              --field status=success \
              --field per_page=1 \
              --jq '.workflow_runs[0]' 2>&1)
            
            if [[ $? -eq 0 && "$api_output" != "null" && -n "$api_output" ]]; then
              response="$api_output"
              echo "‚úÖ Successfully fetched workflow run data."
              break
            else
              echo "‚ö†Ô∏è API call failed or returned empty response on attempt $attempt: $api_output"
              if [[ $attempt -eq 3 ]]; then
                echo "‚ùå Failed to fetch workflow runs after 3 attempts."
                echo "status=api_error" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              sleep 5
            fi
          done

          if ! echo "$response" | jq -e '. | has("id") and has("head_sha")' >/dev/null; then
            echo "‚ùå API response is missing required fields (id, head_sha). Response: $response"
            echo "status=invalid_response" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Safely parse JSON and set outputs
          commit_sha=$(echo "$response" | jq -r '.head_sha')
          run_id=$(echo "$response" | jq -r '.id')

          # Validate parsed data
          if ! [[ "$commit_sha" =~ ^[a-f0-9]{40}$ ]]; then
            echo "‚ùå Invalid commit SHA format: '$commit_sha'"
            echo "status=invalid_commit_sha" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if ! [[ "$run_id" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Invalid run ID format: '$run_id'"
            echo "status=invalid_run_id" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "commit_sha=$commit_sha" >> "$GITHUB_OUTPUT"
          echo "run_id=$run_id" >> "$GITHUB_OUTPUT"
          echo "run_url=$(echo "$response" | jq -r '.html_url')" >> "$GITHUB_OUTPUT"
          echo "commit_short=$(echo "$commit_sha" | cut -c1-7)" >> "$GITHUB_OUTPUT"
          echo "created_at=$(echo "$response" | jq -r '.created_at')" >> "$GITHUB_OUTPUT"
          echo "status=success" >> "$GITHUB_OUTPUT"
          echo "üìä Latest run ID: $run_id, Commit: $commit_sha"

      - name: üì¶ Check for artifacts
        id: check_artifacts
        if: steps.fetch_run.outputs.status == 'success'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          run_id="${{ steps.fetch_run.outputs.run_id }}"
          echo "üì¶ Checking for artifacts in run ID: $run_id"
          
          # Fetch artifacts for the given run ID with retries
          for attempt in {1..3}; do
            artifacts_response=$(gh api "repos/${{ env.TARGET_REPO }}/actions/runs/${run_id}/artifacts" --jq '.artifacts' 2>&1)
            if [[ $? -eq 0 ]]; then
              break
            fi
            echo "‚ö†Ô∏è Failed to fetch artifacts on attempt $attempt. Retrying in 3s..."
            sleep 3
          done

          if [[ $? -ne 0 || -z "$artifacts_response" ]]; then
            echo "‚ùå Failed to fetch artifacts after 3 attempts."
            echo "has_artifacts=error" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          artifact_count=$(echo "$artifacts_response" | jq 'length')
          echo "Found $artifact_count artifacts."

          if [ "$artifact_count" -gt 0 ]; then
            echo "has_artifacts=true" >> "$GITHUB_OUTPUT"
            echo "artifact_count=$artifact_count" >> "$GITHUB_OUTPUT"
            # Use jq to create a clean, numbered list of artifact names
            artifact_list=$(echo "$artifacts_response" | jq -r 'to_entries | map("\(.key + 1). \(.value.name)") | join("\n")')
            echo "artifact_list<<EOF" >> "$GITHUB_OUTPUT"
            echo -e "$artifact_list" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
          else
            echo "has_artifacts=false" >> "$GITHUB_OUTPUT"
          fi

      - name: ü§î Decide if notification is needed
        id: check_notification
        # This step runs if we successfully found a run, regardless of artifact presence,
        # unless a manual trigger requires it.
        if: steps.fetch_run.outputs.status == 'success'
        run: |
          current_commit="${{ steps.fetch_run.outputs.commit_sha }}"
          prev_commit="${{ steps.read_prev_commit.outputs.prev_commit }}"
          has_artifacts="${{ steps.check_artifacts.outputs.has_artifacts }}"
          force_notify="${{ github.event.inputs.force_notification }}"

          echo "üìä Comparison:"
          echo "  Current Commit: $current_commit"
          echo "  Previous Commit: $prev_commit"
          echo "  Force Notify: $force_notify"
          echo "  Has Artifacts: $has_artifacts"
          
          if [[ "$force_notify" == "true" ]]; then
            reason="Manual trigger (force notification)"
            should_notify=true
          elif [[ "$has_artifacts" != "true" ]]; then
            reason="No artifacts found in the latest successful run"
            should_notify=false
          elif [[ -z "$prev_commit" ]]; then
            reason="First run with artifacts detected"
            should_notify=true
          elif [[ "$current_commit" != "$prev_commit" ]]; then
            reason="New commit with artifacts detected"
            should_notify=true
          else
            reason="Already notified for this commit"
            should_notify=false
          fi
          
          echo "should_notify=$should_notify" >> "$GITHUB_OUTPUT"
          echo "reason=$reason" >> "$GITHUB_OUTPUT"
          echo "üëâ Decision: should_notify=$should_notify (Reason: $reason)"

      - name: üíæ Update and save tracking data to cache
        if: steps.check_notification.outputs.should_notify == 'true'
        uses: actions/cache/save@v4
        with:
          path: ${{ env.TRACKING_FILE }}
          key: lsposed-monitor-cache-${{ env.CACHE_VERSION }}
        env:
          COMMIT_SHA: ${{ steps.fetch_run.outputs.commit_sha }}
        run: |
          echo "‚úÖ Updating tracking file with commit: $COMMIT_SHA"
          echo -n "$COMMIT_SHA" > ${{ env.TRACKING_FILE }}
          
      - name: ‚úçÔ∏è Prepare notification message
        id: prepare_message
        if: steps.check_notification.outputs.should_notify == 'true'
        run: |
          # Use a heredoc to build the multi-line message payload cleanly
          payload=$(cat <<EOF
          üîî *LSPosed Monitor Update*

          üì¶ *Repository*: `${{ env.TARGET_REPO }}`
          ‚úÖ *Commit*: `${{ steps.fetch_run.outputs.commit_short }}`
          üìÖ *Build Date*: `${{ steps.fetch_run.outputs.created_at }}`

          üéØ *Artifacts*: ${{ steps.check_artifacts.outputs.artifact_count }} files available
          üìù *Files*:
          ${{ steps.check_artifacts.outputs.artifact_list }}

          üîó [View Workflow Run](${{ steps.fetch_run.outputs.run_url }})

          _Reason: ${{ steps.check_notification.outputs.reason }}_
          EOF
          )
          # Store the payload in a step output
          echo "payload<<EOF" >> "$GITHUB_OUTPUT"
          echo "$payload" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: üöÄ Send Telegram notification
        if: steps.check_notification.outputs.should_notify == 'true'
        # Pin to a specific version for stability instead of @master
        uses: appleboy/telegram-action@v0.1.1
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          format: markdown
          disable_web_page_preview: true
          # Use the cleanly prepared message from the previous step
          message: ${{ steps.prepare_message.outputs.payload }}

      - name: üìù Log workflow summary
        if: always()
        run: |
          echo "## üìä LSPosed Monitor Summary" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.fetch_run.outputs.status }}" == "success" ]]; then
            echo "‚úÖ **Status**: Successfully checked for new artifacts." >> $GITHUB_STEP_SUMMARY
            echo "* **Latest Run**: [${{ steps.fetch_run.outputs.run_id }}](${{ steps.fetch_run.outputs.run_url }})" >> $GITHUB_STEP_SUMMARY
            echo "* **Commit**: \`${{ steps.fetch_run.outputs.commit_short }}\`" >> $GITHUB_STEP_SUMMARY
            
            if [[ "${{ steps.check_artifacts.outputs.has_artifacts }}" == "true" ]]; then
              echo "* **Artifacts**: ${{ steps.check_artifacts.outputs.artifact_count }} found." >> $GITHUB_STEP_SUMMARY
            else
              echo "* **Artifacts**: None found." >> $GITHUB_STEP_SUMMARY
            fi

            if [[ "${{ steps.check_notification.outputs.should_notify }}" == "true" ]]; then
              echo "üîî **Notification**: Sent." >> $GITHUB_STEP_SUMMARY
            else
              echo "üîï **Notification**: Skipped." >> $GITHUB_STEP_SUMMARY
            fi
            echo "* **Reason**: ${{ steps.check_notification.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Status**: Workflow failed." >> $GITHUB_STEP_SUMMARY
            echo "* **Error Code**: `${{ steps.fetch_run.outputs.status }}`" >> $GITHUB_STEP_SUMMARY
            echo "* **Details**: The workflow could not successfully fetch or parse data from the GitHub API." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "_Last checked: $(date -u '+%Y-%m-%d %H:%M:%S UTC')_" >> $GITHUB_STEP_SUMMARY

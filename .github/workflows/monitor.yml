# .github/workflows/monitor_lsposed.yml

name: Monitor LSPosed Artifacts

# New: Define permissions for security best practices.
# GITHUB_TOKEN needs 'actions:read' to read workflow runs.
permissions:
  actions: read
  contents: read

# New: Prevent multiple workflow runs from overlapping.
# This is useful if a run takes longer than the 15-minute schedule interval.
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

on:
  schedule:
    # Runs every 15 minutes to check for new artifacts
    - cron: "*/15 * * * *"
  workflow_dispatch: # Allows manual execution from the Actions tab
    inputs:
      force_notification:
        description: 'Force send notification even if no new commit'
        required: false
        default: false
        type: boolean

env:
  # The repository to monitor for new artifacts
  TARGET_REPO: "JingMatrix/LSPosed"
  # Increment this version to invalidate and clear the cache
  CACHE_VERSION: "v1"

jobs:
  check-for-artifacts:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore last notified commit from cache
        id: cache-restore
        uses: actions/cache/restore@v4
        with:
          path: .github/tracking/last_commit_id.txt
          # The key used to find a cache entry
          key: ${{ runner.os }}-lsposed-monitor-${{ env.CACHE_VERSION }}

      - name: Create tracking directory
        run: mkdir -p .github/tracking

      - name: Fetch latest successful workflow run
        id: fetch_run
        env:
          # Use a PAT for higher rate limits if needed, otherwise fallback to GITHUB_TOKEN
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          echo "ðŸ” Fetching latest successful workflow run from ${{ env.TARGET_REPO }}..."
          
          # Improved: API call is more efficient and error handling is robust.
          # We use query parameters (`?status=success&per_page=1`) instead of fetching all runs.
          # Error output is captured instead of being discarded with `2>/dev/null`.
          for attempt in {1..3}; do
            echo "Attempt $attempt/3"
            
            # Capture both stdout and stderr to handle errors gracefully
            api_output=$(gh api "repos/${{ env.TARGET_REPO }}/actions/runs?status=success&per_page=1" 2>&1)
            exit_code=$? # Capture the exit code of the gh command

            if [ $exit_code -eq 0 ]; then
              response=$(echo "$api_output" | jq '.workflow_runs[0]')
              break
            fi
            
            if [ $attempt -eq 3 ]; then
              echo "âŒ Failed to fetch workflow runs after 3 attempts."
              echo "Error: $api_output"
              exit 1
            fi
            
            echo "â³ Retrying in 5 seconds... (Error: $api_output)"
            sleep 5
          done

          if [ -z "$response" ] || [ "$response" = "null" ]; then
            echo "âŒ No successful workflow runs found."
            echo "status=no_runs" >> "$GITHUB_OUTPUT"
            exit 0 # Exit gracefully, not an error
          fi

          # Improved: Use a single, more efficient jq call to parse all data.
          read -r run_id commit_sha run_url created_at < <(echo "$response" | jq -r '.id, .head_sha, .html_url, .created_at')

          if [ -z "$run_id" ] || [ -z "$commit_sha" ]; then
            echo "âŒ Could not parse a valid run_id or commit_sha from the API response."
            echo "status=api_error" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "âœ… Found Run ID: $run_id"
          echo "commit_sha=$commit_sha" >> "$GITHUB_OUTPUT"
          echo "run_id=$run_id" >> "$GITHUB_OUTPUT"
          echo "run_url=$run_url" >> "$GITHUB_OUTPUT"
          echo "commit_short=$(echo "$commit_sha" | cut -c1-7)" >> "$GITHUB_OUTPUT"
          echo "created_at=$created_at" >> "$GITHUB_OUTPUT"
          echo "status=success" >> "$GITHUB_OUTPUT"

      - name: Check for artifacts in workflow run
        id: check_artifacts
        if: steps.fetch_run.outputs.status == 'success'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          run_id="${{ steps.fetch_run.outputs.run_id }}"
          echo "ðŸ” Checking for artifacts in run ID: $run_id"
          
          # Fetch artifacts using a similar robust retry loop
          for attempt in {1..3}; do
            echo "Attempt $attempt/3 to fetch artifacts"
            artifacts_response=$(gh api "repos/${{ env.TARGET_REPO }}/actions/runs/${run_id}/artifacts" --jq '.artifacts' 2>/dev/null)
            if [ -n "$artifacts_response" ]; then
              break
            fi
            if [ $attempt -eq 3 ]; then
              echo "âŒ Failed to fetch artifacts after 3 attempts."
              echo "has_artifacts=error" >> "$GITHUB_OUTPUT"
              exit 0 # Graceful exit to allow summary
            fi
            echo "â³ Retrying in 3 seconds..."
            sleep 3
          done
          
          artifact_count=$(echo "$artifacts_response" | jq 'length')
          echo "ðŸ“¦ Found $artifact_count artifacts."
          
          if [ "$artifact_count" -gt 0 ]; then
            echo "has_artifacts=true" >> "$GITHUB_OUTPUT"
            echo "artifact_count=$artifact_count" >> "$GITHUB_OUTPUT"
            # Format artifact names for the notification message
            artifact_names=$(echo "$artifacts_response" | jq -r '.[].name' | head -5 | sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/, /g')
            if [ "$artifact_count" -gt 5 ]; then
              echo "artifact_names=${artifact_names}, and $((artifact_count - 5)) more..." >> "$GITHUB_OUTPUT"
            else
              echo "artifact_names=$artifact_names" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "has_artifacts=false" >> "$GITHUB_OUTPUT"
            echo "âŒ No artifacts found in this workflow run."
          fi

      - name: Check if notification is needed
        id: check_notification
        if: steps.fetch_run.outputs.status == 'success' && steps.check_artifacts.outputs.has_artifacts == 'true'
        run: |
          current_commit="${{ steps.fetch_run.outputs.commit_sha }}"
          force_notify="${{ github.event.inputs.force_notification || 'false' }}"
          
          # Read the commit SHA from the last successful notification
          prev_commit=$(cat .github/tracking/last_commit_id.txt 2>/dev/null || echo "")
          
          echo "ðŸ“Š Comparison:"
          echo "  Current Commit: $current_commit"
          echo "  Previous Commit: $prev_commit"
          echo "  Force Notify: $force_notify"
          
          if [ "$force_notify" = "true" ]; then
            echo "should_notify=true" >> "$GITHUB_OUTPUT"
            echo "reason=Manual trigger (force notification)" >> "$GITHUB_OUTPUT"
          elif [ -z "$prev_commit" ]; then
            echo "should_notify=true" >> "$GITHUB_OUTPUT"
            echo "reason=First run with artifacts" >> "$GITHUB_OUTPUT"
          elif [ "$current_commit" != "$prev_commit" ]; then
            echo "should_notify=true" >> "$GITHUB_OUTPUT"
            echo "reason=New commit detected" >> "$GITHUB_OUTPUT"
          else
            echo "should_notify=false" >> "$GITHUB_OUTPUT"
            echo "reason=Already notified for this commit" >> "$GITHUB_OUTPUT"
          fi

      - name: Update and cache tracking data
        if: steps.check_notification.outputs.should_notify == 'true'
        run: |
          echo "âœ… Updating tracking data for commit: ${{ steps.fetch_run.outputs.commit_sha }}"
          echo "${{ steps.fetch_run.outputs.commit_sha }}" > .github/tracking/last_commit_id.txt

      - name: Save tracking data to cache
        # Critical Fix: This step now runs *after* the file is updated and uses a consistent key.
        # This ensures the new commit ID is saved for the next run.
        if: steps.check_notification.outputs.should_notify == 'true'
        uses: actions/cache/save@v4
        with:
          path: .github/tracking/last_commit_id.txt
          # The key MUST match the restore key to be effective.
          key: ${{ runner.os }}-lsposed-monitor-${{ env.CACHE_VERSION }}

      - name: Send Telegram notification
        if: steps.check_notification.outputs.should_notify == 'true'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          format: markdown
          message: |
            ðŸ”” *New LSPosed Artifact Available!*
            
            ðŸ“¦ *Repository*: `${{ env.TARGET_REPO }}`
            âœ… *Commit*: `${{ steps.fetch_run.outputs.commit_short }}`
            ðŸ“… *Build Date*: ${{ steps.fetch_run.outputs.created_at }}
            
            ðŸŽ¯ *Artifacts*: ${{ steps.check_artifacts.outputs.artifact_count }} files available, including:
            \`${{ steps.check_artifacts.outputs.artifact_names }}\`
            
            ðŸ”— *Download from GitHub Actions*:
            ${{ steps.fetch_run.outputs.run_url }}
            
            _Reason: ${{ steps.check_notification.outputs.reason }}. Automated by GitHub Actions_ âš¡ï¸

      - name: Log workflow summary
        if: always()
        run: |
          echo "## ðŸ“Š LSPosed Monitor Summary" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.fetch_run.outputs.status }}" = "success" ]; then
            echo "âœ… **Status**: Successfully checked for new artifacts." >> $GITHUB_STEP_SUMMARY
            echo "* **Latest Run**: [${{ steps.fetch_run.outputs.run_id }}](${{ steps.fetch_run.outputs.run_url }})" >> $GITHUB_STEP_SUMMARY
            echo "* **Commit**: \`${{ steps.fetch_run.outputs.commit_short }}\`" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ steps.check_artifacts.outputs.has_artifacts }}" = "true" ]; then
              echo "* **Artifacts**: ${{ steps.check_artifacts.outputs.artifact_count }} found" >> $GITHUB_STEP_SUMMARY
              if [ "${{ steps.check_notification.outputs.should_notify }}" = "true" ]; then
                echo "ðŸ”” **Notification**: Sent" >> $GITHUB_STEP_SUMMARY
              else
                echo "ðŸ”• **Notification**: Skipped" >> $GITHUB_STEP_SUMMARY
              fi
              echo "* **Reason**: ${{ steps.check_notification.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "ðŸ“¦ **Artifacts**: None found." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âŒ **Status**: Failed to fetch workflow run data." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "_Last checked: $(date -u '+%Y-%m-%d %H:%M:%S UTC')_" >> $GITHUB_STEP_SUMMARY
